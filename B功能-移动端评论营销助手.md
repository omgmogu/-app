# BåŠŸèƒ½ï¼šç§»åŠ¨ç«¯è¯„è®ºåŠ©æ‰‹ - ç”Ÿäº§å®æ–½æ–‡æ¡£

## ğŸ“Š ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½
**ç§»åŠ¨ç«¯è¯„è®ºè¥é”€åŠ©æ‰‹** - åŸºäºæ‰‹åŠ¨ç™»å½•çš„æ™ºèƒ½å•†å“è¯„è®ºè‡ªåŠ¨åŒ–ç³»ç»Ÿ

### ä¸»è¦ç‰¹è‰²
- **æ‰‹åŠ¨ç™»å½•**ï¼šç”¨æˆ·æ§åˆ¶è´¦å·å®‰å…¨ï¼Œç³»ç»Ÿè¿æ¥å·²ç™»å½•APPä¼šè¯
- **æ™ºèƒ½åˆ†æ**ï¼šæ·±åº¦æå–å•†å“ä¿¡æ¯å’Œç«å“è¯„è®ºæ•°æ®
- **AIæ–‡æ¡ˆç”Ÿæˆ**ï¼šåŸºäºDeepSeek AIæ ¹æ®è§„åˆ™ç”Ÿæˆå¤šæ ·åŒ–è¯„è®º
- **æœ¬åœ°è¿è¡Œ**ï¼šå®Œå…¨æœ¬åœ°åŒ–éƒ¨ç½²ï¼Œæ•°æ®å®‰å…¨å¯æ§

### å·¥ä½œæµç¨‹
```
ç”¨æˆ·æ‰‹åŠ¨ç™»å½•APP â†’ ç³»ç»Ÿè¿æ¥ä¼šè¯ â†’ å¯¼èˆªå•†å“é¡µé¢ â†’ æå–å•†å“ä¿¡æ¯ â†’ AIç”Ÿæˆæ–‡æ¡ˆ â†’ è‡ªåŠ¨å‘å¸ƒè¯„è®º â†’ è®°å½•ç»Ÿè®¡
```

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·æ‰‹åŠ¨ç™»å½•   â”‚ â†’  â”‚  Appiumæ§åˆ¶å™¨   â”‚ â†’  â”‚  å•†å“ä¿¡æ¯æå–   â”‚
â”‚   ç§»åŠ¨APP   â”‚    â”‚   APPä¼šè¯      â”‚    â”‚   UIå…ƒç´ å®šä½    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚                        â”‚
                                â†“                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç®¡ç†ç•Œé¢GUI   â”‚ â†  â”‚  SQLiteæ•°æ®åº“   â”‚ â†  â”‚  DeepSeek AI    â”‚
â”‚   ä»»åŠ¡æ§åˆ¶å°    â”‚    â”‚   å•†å“æ•°æ®      â”‚    â”‚   æ–‡æ¡ˆç”Ÿæˆ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚                        â”‚
                                â†“                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•ˆæœç»Ÿè®¡      â”‚ â†  â”‚  è¯„è®ºå‘å¸ƒæ¨¡å—   â”‚ â†  â”‚  åæ£€æµ‹æ§åˆ¶     â”‚
â”‚   æ•°æ®åˆ†æ      â”‚    â”‚   è‡ªåŠ¨æ“ä½œ      â”‚    â”‚   è¡Œä¸ºæ¨¡æ‹Ÿ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ
```yaml
ç¼–ç¨‹è¯­è¨€: Python 3.8+
ç§»åŠ¨è‡ªåŠ¨åŒ–: Appium + UiAutomator2
AIæœåŠ¡: DeepSeek API
æ•°æ®åº“: SQLite
GUIæ¡†æ¶: Tkinter
éƒ¨ç½²æ–¹å¼: å•æœºæœ¬åœ°è¿è¡Œ
```

## ğŸ› ï¸ ç¯å¢ƒæ­å»º

### ç³»ç»Ÿè¦æ±‚
- **æ“ä½œç³»ç»Ÿ**: Windows 10/11, macOS 10.15+, Ubuntu 18.04+
- **å†…å­˜**: 6GB+ RAM (å«Androidæ¨¡æ‹Ÿå™¨)
- **å­˜å‚¨**: 3GB+ å¯ç”¨ç©ºé—´
- **è®¾å¤‡**: Androidæ‰‹æœºæˆ–æ¨¡æ‹Ÿå™¨ (API 23+)
- **ç½‘ç»œ**: ç¨³å®šç½‘ç»œè¿æ¥ï¼ˆç”¨äºAPIè°ƒç”¨ï¼‰

### å®‰è£…æ­¥éª¤

#### 1. Javaå’ŒAndroidç¯å¢ƒ
```bash
# å®‰è£…Java JDK 8+
java -version  # ç¡®è®¤å®‰è£…

# ä¸‹è½½Android SDK
# è®¾ç½®ç¯å¢ƒå˜é‡
export JAVA_HOME=/path/to/jdk
export ANDROID_HOME=/path/to/android-sdk
export PATH=$PATH:$ANDROID_HOME/platform-tools:$ANDROID_HOME/tools
```

#### 2. Pythonç¯å¢ƒé…ç½®
```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv xianyu_comment_env

# æ¿€æ´»ç¯å¢ƒ
# Windows
xianyu_comment_env\Scripts\activate
# macOS/Linux
source xianyu_comment_env/bin/activate

# å®‰è£…æ ¸å¿ƒä¾èµ–
pip install appium-python-client selenium requests sqlite3 tkinter Pillow
```

#### 3. Appium Serverå®‰è£…
```bash
# å®‰è£…Node.js (16+)
node --version

# å®‰è£…Appium
npm install -g appium

# å®‰è£…UiAutomator2é©±åŠ¨
appium driver install uiautomator2

# éªŒè¯å®‰è£…
appium --version
```

#### 4. Androidè®¾å¤‡é…ç½®
```bash
# çœŸæœºé…ç½®
# 1. å¼€å¯å¼€å‘è€…é€‰é¡¹
# 2. å¯ç”¨USBè°ƒè¯•
# 3. è¿æ¥è®¾å¤‡ï¼Œç¡®è®¤æˆæƒ

# éªŒè¯è¿æ¥
adb devices

# æ¨¡æ‹Ÿå™¨é…ç½®ï¼ˆå¯é€‰ï¼‰
# æ¨èä½¿ç”¨Android Studio AVDæˆ–å¤œç¥æ¨¡æ‹Ÿå™¨
```

#### 5. é¡¹ç›®ç›®å½•ç»“æ„
```
xianyu-comment-assistant/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.py                 # ä¸»ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ app_controller.py       # APPæ§åˆ¶å™¨
â”‚   â”œâ”€â”€ product_analyzer.py     # å•†å“åˆ†æå™¨
â”‚   â”œâ”€â”€ comment_generator.py    # è¯„è®ºç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ comment_publisher.py    # è¯„è®ºå‘å¸ƒå™¨
â”‚   â”œâ”€â”€ ai_client.py           # AIå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ database.py            # æ•°æ®åº“ç®¡ç†
â”‚   â”œâ”€â”€ gui.py                 # GUIç•Œé¢
â”‚   â””â”€â”€ config.py              # é…ç½®ç®¡ç†
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ products.db            # å•†å“æ•°æ®åº“
â”‚   â”œâ”€â”€ comments.db            # è¯„è®ºè®°å½•
â”‚   â””â”€â”€ logs/                  # æ—¥å¿—æ–‡ä»¶
â”œâ”€â”€ config/
â”‚   â””â”€â”€ settings.yaml          # é…ç½®æ–‡ä»¶
â”œâ”€â”€ templates/                 # æ–‡æ¡ˆæ¨¡æ¿
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

## ğŸ’» æ ¸å¿ƒä»£ç å®ç°

### 1. ä¸»ç¨‹åºæ§åˆ¶å™¨
```python
# src/main.py
import asyncio
import logging
from app_controller import AppController
from product_analyzer import ProductAnalyzer
from comment_generator import CommentGenerator
from comment_publisher import CommentPublisher
from gui import CommentAssistantGUI
from database import Database

class CommentAssistant:
    def __init__(self):
        self.app_controller = AppController()
        self.product_analyzer = ProductAnalyzer()
        self.comment_generator = CommentGenerator()
        self.comment_publisher = CommentPublisher()
        self.database = Database()
        self.gui = CommentAssistantGUI(self)
        self.running = False
        self.current_task = None
    
    def start_batch_task(self, product_urls, comment_types):
        """å¼€å§‹æ‰¹é‡ä»»åŠ¡"""
        try:
            # è¿æ¥APP
            if not self.app_controller.connect():
                raise Exception("æ— æ³•è¿æ¥åˆ°APP")
            
            self.running = True
            self.current_task = {
                'product_urls': product_urls,
                'comment_types': comment_types,
                'total': len(product_urls),
                'completed': 0,
                'errors': 0
            }
            
            # å¯åŠ¨ä»»åŠ¡å¤„ç†
            self.process_products()
            
        except Exception as e:
            logging.error(f"å¯åŠ¨æ‰¹é‡ä»»åŠ¡å¤±è´¥: {e}")
            self.gui.show_error(f"å¯åŠ¨å¤±è´¥: {e}")
    
    def process_products(self):
        """å¤„ç†å•†å“åˆ—è¡¨"""
        for i, product_url in enumerate(self.current_task['product_urls']):
            if not self.running:
                break
            
            try:
                # æ›´æ–°è¿›åº¦
                self.gui.update_progress(i + 1, self.current_task['total'])
                
                # å¯¼èˆªåˆ°å•†å“é¡µé¢
                if not self.app_controller.navigate_to_product(product_url):
                    self.current_task['errors'] += 1
                    continue
                
                # æå–å•†å“ä¿¡æ¯
                product_info = self.product_analyzer.extract_product_info()
                if not product_info:
                    self.current_task['errors'] += 1
                    continue
                
                # ç”Ÿæˆè¯„è®ºæ–‡æ¡ˆ
                comments = self.comment_generator.generate_comments(
                    product_info, 
                    self.current_task['comment_types']
                )
                
                # å‘å¸ƒè¯„è®º
                success_count = self.comment_publisher.publish_comments(
                    comments, product_info['id']
                )
                
                # ä¿å­˜è®°å½•
                self.database.save_product_task(
                    product_url, product_info, comments, success_count
                )
                
                self.current_task['completed'] += 1
                
                # ä»»åŠ¡é—´éš”
                time.sleep(random.uniform(30, 60))  # 30-60ç§’é—´éš”
                
            except Exception as e:
                logging.error(f"å¤„ç†å•†å“å¤±è´¥ {product_url}: {e}")
                self.current_task['errors'] += 1
        
        # ä»»åŠ¡å®Œæˆ
        self.finish_task()
    
    def finish_task(self):
        """å®Œæˆä»»åŠ¡"""
        self.running = False
        
        # ç”Ÿæˆä»»åŠ¡æŠ¥å‘Š
        report = {
            'total': self.current_task['total'],
            'completed': self.current_task['completed'],
            'errors': self.current_task['errors'],
            'success_rate': self.current_task['completed'] / self.current_task['total']
        }
        
        self.gui.show_task_report(report)
        self.current_task = None

if __name__ == "__main__":
    assistant = CommentAssistant()
    assistant.gui.run()
```

### 2. APPæ§åˆ¶å™¨
```python
# src/app_controller.py
from appium import webdriver
from appium.webdriver.common.appiumby import AppiumBy
import time
import logging

class AppController:
    def __init__(self):
        self.driver = None
        self.desired_caps = {
            'platformName': 'Android',
            'automationName': 'UiAutomator2',
            'appPackage': 'com.taobao.idlefish',
            'appActivity': '.maincontainer.activity.MainActivity',
            'noReset': True,  # ä¿æŒç™»å½•çŠ¶æ€
            'newCommandTimeout': 300,
            'settings[waitForIdleTimeout]': 100
        }
    
    def connect(self, device_id=None):
        """è¿æ¥åˆ°APP"""
        try:
            if device_id:
                self.desired_caps['udid'] = device_id
            
            self.driver = webdriver.Remote(
                'http://localhost:4723/wd/hub',
                self.desired_caps
            )
            
            # è®¾ç½®éšå¼ç­‰å¾…
            self.driver.implicitly_wait(10)
            
            # ç­‰å¾…APPå®Œå…¨åŠ è½½
            time.sleep(3)
            
            # éªŒè¯APPæ˜¯å¦æ­£å¸¸
            if self.verify_app_ready():
                logging.info("æˆåŠŸè¿æ¥åˆ°APP")
                return True
            else:
                raise Exception("APPæœªæ­£ç¡®åŠ è½½")
                
        except Exception as e:
            logging.error(f"è¿æ¥APPå¤±è´¥: {e}")
            return False
    
    def verify_app_ready(self):
        """éªŒè¯APPæ˜¯å¦å°±ç»ª"""
        try:
            # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸»è¦å¯¼èˆªå…ƒç´ 
            tab_elements = self.driver.find_elements(
                AppiumBy.XPATH, 
                "//android.widget.TabWidget//android.widget.TextView"
            )
            
            return len(tab_elements) > 0
            
        except:
            return False
    
    def navigate_to_product(self, product_url):
        """å¯¼èˆªåˆ°å•†å“é¡µé¢"""
        try:
            # æ–¹æ³•1: é€šè¿‡URL scheme
            if product_url.startswith('http'):
                # æå–å•†å“ID
                product_id = self.extract_product_id(product_url)
                scheme_url = f"fleamarket://item?id={product_id}"
                self.driver.get(scheme_url)
            else:
                # ç›´æ¥ä½¿ç”¨URL
                self.driver.get(product_url)
            
            # ç­‰å¾…é¡µé¢åŠ è½½
            time.sleep(5)
            
            # éªŒè¯å•†å“é¡µé¢åŠ è½½æˆåŠŸ
            if self.verify_product_page():
                return True
            else:
                # æ–¹æ³•2: é€šè¿‡æœç´¢å¯¼èˆª
                return self.navigate_by_search(product_url)
                
        except Exception as e:
            logging.error(f"å¯¼èˆªåˆ°å•†å“é¡µé¢å¤±è´¥: {e}")
            return False
    
    def verify_product_page(self):
        """éªŒè¯å•†å“é¡µé¢"""
        try:
            # æ£€æŸ¥å•†å“æ ‡é¢˜å…ƒç´ 
            title_element = self.driver.find_element(
                AppiumBy.XPATH,
                "//android.widget.TextView[contains(@resource-id,'title')]"
            )
            
            return title_element is not None
            
        except:
            return False
    
    def navigate_by_search(self, product_url):
        """é€šè¿‡æœç´¢å¯¼èˆªåˆ°å•†å“"""
        try:
            # ç‚¹å‡»æœç´¢æŒ‰é’®
            search_btn = self.driver.find_element(
                AppiumBy.ID, "com.taobao.idlefish:id/search_btn"
            )
            search_btn.click()
            
            # è¾“å…¥å•†å“URLæˆ–å…³é”®è¯
            search_input = self.driver.find_element(
                AppiumBy.ID, "com.taobao.idlefish:id/search_input"
            )
            search_input.send_keys(product_url)
            
            # ç‚¹å‡»æœç´¢
            search_confirm = self.driver.find_element(
                AppiumBy.ID, "com.taobao.idlefish:id/search_confirm"
            )
            search_confirm.click()
            
            time.sleep(3)
            return True
            
        except Exception as e:
            logging.error(f"æœç´¢å¯¼èˆªå¤±è´¥: {e}")
            return False
    
    def extract_product_id(self, url):
        """æå–å•†å“ID"""
        import re
        pattern = r'item/(\d+)'
        match = re.search(pattern, url)
        return match.group(1) if match else None
    
    def scroll_page(self, direction='down', distance=1000):
        """æ»šåŠ¨é¡µé¢"""
        try:
            size = self.driver.get_window_size()
            width = size['width']
            height = size['height']
            
            if direction == 'down':
                self.driver.swipe(width//2, height*0.8, width//2, height*0.2)
            elif direction == 'up':
                self.driver.swipe(width//2, height*0.2, width//2, height*0.8)
                
            time.sleep(1)
            return True
            
        except Exception as e:
            logging.error(f"æ»šåŠ¨é¡µé¢å¤±è´¥: {e}")
            return False
    
    def take_screenshot(self, filename):
        """æˆªå›¾"""
        try:
            self.driver.save_screenshot(filename)
            return True
        except Exception as e:
            logging.error(f"æˆªå›¾å¤±è´¥: {e}")
            return False
    
    def quit(self):
        """é€€å‡ºé©±åŠ¨"""
        if self.driver:
            self.driver.quit()
            self.driver = None
```

### 3. å•†å“ä¿¡æ¯åˆ†æå™¨
```python
# src/product_analyzer.py
from appium.webdriver.common.appiumby import AppiumBy
import time
import logging
import re

class ProductAnalyzer:
    def __init__(self, app_controller):
        self.app = app_controller
        self.driver = app_controller.driver
    
    def extract_product_info(self):
        """æå–å•†å“ä¿¡æ¯"""
        try:
            product_info = {}
            
            # æå–å•†å“æ ‡é¢˜
            product_info['title'] = self.extract_title()
            
            # æå–ä»·æ ¼
            product_info['price'] = self.extract_price()
            
            # æå–æè¿°
            product_info['description'] = self.extract_description()
            
            # æå–å–å®¶ä¿¡æ¯
            product_info['seller'] = self.extract_seller_info()
            
            # æå–å•†å“çŠ¶æ€
            product_info['condition'] = self.extract_condition()
            
            # æå–ä½ç½®ä¿¡æ¯
            product_info['location'] = self.extract_location()
            
            # æå–ç°æœ‰è¯„è®º
            product_info['existing_comments'] = self.extract_existing_comments()
            
            # ç”Ÿæˆå•†å“ID
            product_info['id'] = self.generate_product_id(product_info)
            
            logging.info(f"æˆåŠŸæå–å•†å“ä¿¡æ¯: {product_info['title']}")
            return product_info
            
        except Exception as e:
            logging.error(f"æå–å•†å“ä¿¡æ¯å¤±è´¥: {e}")
            return None
    
    def extract_title(self):
        """æå–å•†å“æ ‡é¢˜"""
        try:
            # å°è¯•å¤šç§é€‰æ‹©å™¨
            selectors = [
                "//android.widget.TextView[contains(@resource-id,'title')]",
                "//android.widget.TextView[contains(@text,'')][@index='0']",
                "//*[contains(@class,'TextView')][1]"
            ]
            
            for selector in selectors:
                try:
                    element = self.driver.find_element(AppiumBy.XPATH, selector)
                    text = element.text.strip()
                    if text and len(text) > 5:  # ç¡®ä¿æ˜¯æœ‰æ„ä¹‰çš„æ ‡é¢˜
                        return text
                except:
                    continue
            
            return "æœªçŸ¥å•†å“"
            
        except Exception as e:
            logging.error(f"æå–æ ‡é¢˜å¤±è´¥: {e}")
            return "æœªçŸ¥å•†å“"
    
    def extract_price(self):
        """æå–ä»·æ ¼"""
        try:
            # å¯»æ‰¾åŒ…å«Â¥ç¬¦å·çš„å…ƒç´ 
            price_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView[contains(@text,'Â¥')]"
            )
            
            for element in price_elements:
                text = element.text
                # æå–æ•°å­—ä»·æ ¼
                price_match = re.search(r'Â¥(\d+(?:\.\d{2})?)', text)
                if price_match:
                    return float(price_match.group(1))
            
            return 0.0
            
        except Exception as e:
            logging.error(f"æå–ä»·æ ¼å¤±è´¥: {e}")
            return 0.0
    
    def extract_description(self):
        """æå–å•†å“æè¿°"""
        try:
            # æ»šåŠ¨åˆ°æè¿°éƒ¨åˆ†
            self.app.scroll_page('down')
            time.sleep(2)
            
            # æŸ¥æ‰¾æè¿°æ–‡æœ¬
            desc_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView"
            )
            
            # åˆå¹¶æè¿°æ–‡æœ¬ï¼Œè¿‡æ»¤æ‰çŸ­æ–‡æœ¬
            descriptions = []
            for element in desc_elements:
                text = element.text.strip()
                if text and len(text) > 10 and not self.is_ui_element(text):
                    descriptions.append(text)
            
            return ' '.join(descriptions[:3])  # å–å‰3æ®µæè¿°
            
        except Exception as e:
            logging.error(f"æå–æè¿°å¤±è´¥: {e}")
            return ""
    
    def extract_seller_info(self):
        """æå–å–å®¶ä¿¡æ¯"""
        try:
            # æŸ¥æ‰¾å–å®¶åç§°
            seller_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView[contains(@resource-id,'seller') or contains(@resource-id,'user')]"
            )
            
            for element in seller_elements:
                text = element.text.strip()
                if text and not text.isdigit():
                    return text
            
            return "æœªçŸ¥å–å®¶"
            
        except Exception as e:
            logging.error(f"æå–å–å®¶ä¿¡æ¯å¤±è´¥: {e}")
            return "æœªçŸ¥å–å®¶"
    
    def extract_condition(self):
        """æå–å•†å“æˆè‰²"""
        try:
            # æŸ¥æ‰¾æˆè‰²ç›¸å…³æ–‡æœ¬
            condition_keywords = ['å…¨æ–°', 'å‡ ä¹å…¨æ–°', 'è½»å¾®ä½¿ç”¨ç—•è¿¹', 'æ˜æ˜¾ä½¿ç”¨ç—•è¿¹']
            
            all_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView"
            )
            
            for element in all_elements:
                text = element.text.strip()
                for keyword in condition_keywords:
                    if keyword in text:
                        return keyword
            
            return "æœªçŸ¥æˆè‰²"
            
        except Exception as e:
            logging.error(f"æå–æˆè‰²å¤±è´¥: {e}")
            return "æœªçŸ¥æˆè‰²"
    
    def extract_location(self):
        """æå–ä½ç½®ä¿¡æ¯"""
        try:
            # æŸ¥æ‰¾ä½ç½®å…ƒç´ 
            location_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView[contains(@text,'å¸‚') or contains(@text,'åŒº') or contains(@text,'å¿')]"
            )
            
            for element in location_elements:
                text = element.text.strip()
                if 'å¸‚' in text or 'åŒº' in text:
                    return text
            
            return "æœªçŸ¥ä½ç½®"
            
        except Exception as e:
            logging.error(f"æå–ä½ç½®å¤±è´¥: {e}")
            return "æœªçŸ¥ä½ç½®"
    
    def extract_existing_comments(self, limit=5):
        """æå–ç°æœ‰è¯„è®º"""
        try:
            # æ»šåŠ¨åˆ°è¯„è®ºåŒº
            self.scroll_to_comments()
            
            comment_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.LinearLayout[contains(@resource-id,'comment')]"
            )
            
            comments = []
            for element in comment_elements[:limit]:
                try:
                    # æå–è¯„è®ºå†…å®¹
                    content_elem = element.find_element(
                        AppiumBy.XPATH,
                        ".//android.widget.TextView"
                    )
                    
                    comment_text = content_elem.text.strip()
                    if comment_text and len(comment_text) > 3:
                        comments.append(comment_text)
                        
                except:
                    continue
            
            return comments
            
        except Exception as e:
            logging.error(f"æå–ç°æœ‰è¯„è®ºå¤±è´¥: {e}")
            return []
    
    def scroll_to_comments(self):
        """æ»šåŠ¨åˆ°è¯„è®ºåŒº"""
        try:
            # å¤šæ¬¡å‘ä¸‹æ»šåŠ¨å¯»æ‰¾è¯„è®ºåŒº
            for _ in range(3):
                self.app.scroll_page('down')
                time.sleep(1)
                
                # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°è¯„è®ºåŒº
                comment_indicators = [
                    "//android.widget.TextView[contains(@text,'è¯„è®º')]",
                    "//android.widget.TextView[contains(@text,'ç•™è¨€')]",
                    "//*[contains(@resource-id,'comment')]"
                ]
                
                for indicator in comment_indicators:
                    try:
                        self.driver.find_element(AppiumBy.XPATH, indicator)
                        return True
                    except:
                        continue
            
            return False
            
        except Exception as e:
            logging.error(f"æ»šåŠ¨åˆ°è¯„è®ºåŒºå¤±è´¥: {e}")
            return False
    
    def is_ui_element(self, text):
        """åˆ¤æ–­æ˜¯å¦ä¸ºUIå…ƒç´ æ–‡æœ¬"""
        ui_texts = [
            'ç«‹å³è´­ä¹°', 'åŠ å…¥è´­ç‰©è½¦', 'æ”¶è—', 'åˆ†äº«', 'è¯„è®º', 'ç‚¹èµ',
            'æŸ¥çœ‹è¯¦æƒ…', 'è”ç³»å–å®¶', 'ä¸¾æŠ¥', 'å–æ¶ˆ', 'ç¡®å®š'
        ]
        
        return any(ui_text in text for ui_text in ui_texts)
    
    def generate_product_id(self, product_info):
        """ç”Ÿæˆå•†å“ID"""
        import hashlib
        
        content = f"{product_info.get('title', '')}{product_info.get('price', 0)}"
        return hashlib.md5(content.encode()).hexdigest()[:12]
    
    def analyze_market_position(self, product_info):
        """åˆ†æå¸‚åœºå®šä½"""
        try:
            analysis = {
                'price_level': self.categorize_price(product_info['price']),
                'condition_score': self.score_condition(product_info['condition']),
                'description_quality': self.score_description(product_info['description']),
                'competition_level': len(product_info.get('existing_comments', []))
            }
            
            return analysis
            
        except Exception as e:
            logging.error(f"å¸‚åœºå®šä½åˆ†æå¤±è´¥: {e}")
            return {}
    
    def categorize_price(self, price):
        """ä»·æ ¼åˆ†ç±»"""
        if price <= 50:
            return "ä½ä»·"
        elif price <= 200:
            return "ä¸­ä½ä»·"
        elif price <= 500:
            return "ä¸­ä»·"
        elif price <= 1000:
            return "ä¸­é«˜ä»·"
        else:
            return "é«˜ä»·"
    
    def score_condition(self, condition):
        """æˆè‰²è¯„åˆ†"""
        condition_scores = {
            "å…¨æ–°": 5,
            "å‡ ä¹å…¨æ–°": 4,
            "è½»å¾®ä½¿ç”¨ç—•è¿¹": 3,
            "æ˜æ˜¾ä½¿ç”¨ç—•è¿¹": 2
        }
        return condition_scores.get(condition, 1)
    
    def score_description(self, description):
        """æè¿°è´¨é‡è¯„åˆ†"""
        if len(description) > 100:
            return 5
        elif len(description) > 50:
            return 4
        elif len(description) > 20:
            return 3
        else:
            return 2
```

### 4. AIè¯„è®ºç”Ÿæˆå™¨
```python
# src/comment_generator.py
import aiohttp
import asyncio
import random
import logging
from ai_client import DeepSeekClient

class CommentGenerator:
    def __init__(self):
        self.ai_client = DeepSeekClient()
        self.comment_types = {
            'inquiry': 'è¯¢ä»·å‹è¯„è®º',
            'interest': 'æ„Ÿå…´è¶£å‹è¯„è®º',
            'comparison': 'å¯¹æ¯”å’¨è¯¢å‹è¯„è®º',
            'compliment': 'å¤¸èµå‹è¯„è®º',
            'concern': 'å…³æ³¨å‹è¯„è®º'
        }
    
    def generate_comments(self, product_info, comment_types, count=3):
        """ç”Ÿæˆå¤šç§ç±»å‹è¯„è®º"""
        try:
            all_comments = []
            
            for comment_type in comment_types:
                comments = self.generate_type_comments(
                    product_info, comment_type, count
                )
                all_comments.extend(comments)
            
            # å»é‡å’Œè´¨é‡è¿‡æ»¤
            filtered_comments = self.filter_comments(all_comments)
            
            logging.info(f"ç”Ÿæˆè¯„è®ºæ•°é‡: {len(filtered_comments)}")
            return filtered_comments
            
        except Exception as e:
            logging.error(f"ç”Ÿæˆè¯„è®ºå¤±è´¥: {e}")
            return []
    
    def generate_type_comments(self, product_info, comment_type, count=3):
        """ç”Ÿæˆç‰¹å®šç±»å‹è¯„è®º"""
        try:
            prompt = self.build_comment_prompt(product_info, comment_type)
            
            # è°ƒç”¨AIç”Ÿæˆ
            response = asyncio.run(
                self.ai_client.generate_content(prompt, max_tokens=200)
            )
            
            # è§£æç”Ÿæˆçš„è¯„è®º
            comments = self.parse_generated_comments(response, comment_type)
            
            return comments[:count]
            
        except Exception as e:
            logging.error(f"ç”Ÿæˆ{comment_type}è¯„è®ºå¤±è´¥: {e}")
            return []
    
    def build_comment_prompt(self, product_info, comment_type):
        """æ„å»ºè¯„è®ºç”Ÿæˆæç¤ºè¯"""
        base_context = f"""
        å•†å“ä¿¡æ¯ï¼š
        æ ‡é¢˜ï¼š{product_info.get('title', 'æœªçŸ¥å•†å“')}
        ä»·æ ¼ï¼šÂ¥{product_info.get('price', 0)}
        æˆè‰²ï¼š{product_info.get('condition', 'æœªçŸ¥')}
        å–å®¶ï¼š{product_info.get('seller', 'æœªçŸ¥å–å®¶')}
        ä½ç½®ï¼š{product_info.get('location', 'æœªçŸ¥ä½ç½®')}
        æè¿°ï¼š{product_info.get('description', '')[:100]}
        ç°æœ‰è¯„è®ºï¼š{product_info.get('existing_comments', [])[:3]}
        """
        
        if comment_type == 'inquiry':
            prompt = base_context + """
            è¯·ç”Ÿæˆ3æ¡è¯¢ä»·å‹è¯„è®ºï¼Œè¦æ±‚ï¼š
            1. è¯­æ°”è‡ªç„¶å‹å–„ï¼ŒåƒçœŸå®ä¹°å®¶
            2. ä½“ç°å¯¹å•†å“çš„å…´è¶£å’Œä»·æ ¼æ•æ„Ÿ
            3. æ¯æ¡è¯„è®º10-25å­—
            4. é¿å…è¿‡åˆ†ç›´æ¥ç ä»·
            5. å¯ä»¥è¯¢é—®ç»†èŠ‚æˆ–è®®ä»·ç©ºé—´
            
            ç¤ºä¾‹æ ¼å¼ï¼š
            1. è¿™ä¸ªä»·æ ¼è¿˜èƒ½ä¼˜æƒ ä¸€äº›å—ï¼Ÿä¸œè¥¿çœ‹èµ·æ¥ä¸é”™
            2. åŒ…é‚®å—ï¼Ÿå¯ä»¥å°åˆ€ä¸€ä¸‹å—ï¼Ÿ
            3. èƒ½ä¾¿å®œç‚¹å—ï¼Ÿè¯šå¿ƒæƒ³è¦
            """
        
        elif comment_type == 'interest':
            prompt = base_context + """
            è¯·ç”Ÿæˆ3æ¡æ„Ÿå…´è¶£å‹è¯„è®ºï¼Œè¦æ±‚ï¼š
            1. è¡¨è¾¾å¯¹å•†å“çš„å…´è¶£å’Œè´­ä¹°æ„å‘
            2. è¯­æ°”ç§¯ææ­£é¢
            3. æ¯æ¡è¯„è®º8-20å­—
            4. å¯ä»¥è¯¢é—®ä½¿ç”¨æƒ…å†µæˆ–ç»†èŠ‚
            
            ç¤ºä¾‹æ ¼å¼ï¼š
            1. è¿™ä¸ªè¿˜åœ¨å—ï¼Ÿå¾ˆæ„Ÿå…´è¶£
            2. ä¸œè¥¿çœ‹èµ·æ¥ä¸é”™ï¼Œç”¨äº†å¤šä¹…ï¼Ÿ
            3. æ­£å¥½éœ€è¦è¿™ä¸ªï¼Œè´¨é‡æ€ä¹ˆæ ·ï¼Ÿ
            """
        
        elif comment_type == 'comparison':
            prompt = base_context + """
            è¯·ç”Ÿæˆ3æ¡å¯¹æ¯”å’¨è¯¢å‹è¯„è®ºï¼Œè¦æ±‚ï¼š
            1. è¯¢é—®å•†å“ç»†èŠ‚å’Œä¸å…¶ä»–å•†å“çš„å¯¹æ¯”
            2. æ˜¾ç¤ºä¸“ä¸šçš„è´­ä¹°çœ¼å…‰
            3. æ¯æ¡è¯„è®º15-30å­—
            4. ä½“ç°å¯¹å•†å“çš„æ·±å…¥äº†è§£
            
            ç¤ºä¾‹æ ¼å¼ï¼š
            1. è¿™ä¸ªå’ŒXXå“ç‰Œçš„æœ‰ä»€ä¹ˆåŒºåˆ«ï¼ŸåŠŸèƒ½ä¸€æ ·å—ï¼Ÿ
            2. è¿™æ¬¾æ¯”æ–°çš„ä¾¿å®œå¤šå°‘ï¼Ÿæˆè‰²çœ‹èµ·æ¥å¾ˆå¥½
            3. å’ŒåŒç±»äº§å“ç›¸æ¯”ä¼˜åŠ¿åœ¨å“ªé‡Œï¼Ÿ
            """
        
        elif comment_type == 'compliment':
            prompt = base_context + """
            è¯·ç”Ÿæˆ3æ¡å¤¸èµå‹è¯„è®ºï¼Œè¦æ±‚ï¼š
            1. å¤¸èµå•†å“æˆ–å–å®¶
            2. è¯­æ°”çœŸè¯šè‡ªç„¶
            3. æ¯æ¡è¯„è®º8-18å­—
            4. å¯ä»¥å¤¸å•†å“ä¿å…»å¥½æˆ–ä»·æ ¼åˆç†
            
            ç¤ºä¾‹æ ¼å¼ï¼š
            1. ä¿å…»å¾—çœŸå¥½ï¼Œå–å®¶å¾ˆç”¨å¿ƒ
            2. è¿™ä¸ªä»·æ ¼å¾ˆåˆç†ï¼Œè‰¯å¿ƒå–å®¶
            3. ä¸œè¥¿çœ‹èµ·æ¥è·Ÿæ–°çš„ä¸€æ ·
            """
        
        elif comment_type == 'concern':
            prompt = base_context + """
            è¯·ç”Ÿæˆ3æ¡å…³æ³¨å‹è¯„è®ºï¼Œè¦æ±‚ï¼š
            1. è¡¨è¾¾å…³æ³¨å’Œåç»­è”ç³»æ„å‘
            2. è¯­æ°”å‹å–„
            3. æ¯æ¡è¯„è®º8-15å­—
            4. æš—ç¤ºå¯èƒ½è´­ä¹°
            
            ç¤ºä¾‹æ ¼å¼ï¼š
            1. å…ˆå…³æ³¨ä¸€ä¸‹ï¼Œè€ƒè™‘è€ƒè™‘
            2. å·²å…³æ³¨ï¼Œæœ‰ä¼˜æƒ è®°å¾—é€šçŸ¥
            3. æ”¶è—äº†ï¼Œè¿‡ä¸¤å¤©è”ç³»
            """
        
        return prompt
    
    def parse_generated_comments(self, response, comment_type):
        """è§£æAIç”Ÿæˆçš„è¯„è®º"""
        try:
            comments = []
            lines = response.split('\n')
            
            for line in lines:
                line = line.strip()
                
                # ç§»é™¤åºå·å’Œæ ¼å¼ç¬¦å·
                import re
                cleaned = re.sub(r'^\d+\.\s*', '', line)
                cleaned = re.sub(r'^[-â€¢]\s*', '', cleaned)
                cleaned = cleaned.strip()
                
                # éªŒè¯è¯„è®ºè´¨é‡
                if self.validate_comment(cleaned):
                    comments.append({
                        'content': cleaned,
                        'type': comment_type,
                        'length': len(cleaned)
                    })
            
            return comments
            
        except Exception as e:
            logging.error(f"è§£æè¯„è®ºå¤±è´¥: {e}")
            return []
    
    def validate_comment(self, comment):
        """éªŒè¯è¯„è®ºè´¨é‡"""
        if not comment or len(comment) < 5:
            return False
        
        if len(comment) > 50:
            return False
        
        # è¿‡æ»¤é‡å¤å†…å®¹
        if comment.count('ã€‚') > 2:
            return False
        
        # è¿‡æ»¤ä¸å½“å†…å®¹
        inappropriate_words = ['åƒåœ¾', 'éª—å­', 'å‡è´§', 'å·®è¯„']
        if any(word in comment for word in inappropriate_words):
            return False
        
        return True
    
    def filter_comments(self, comments):
        """è¿‡æ»¤å’Œå»é‡è¯„è®º"""
        try:
            # å»é‡
            seen_contents = set()
            filtered = []
            
            for comment in comments:
                content = comment['content']
                if content not in seen_contents:
                    seen_contents.add(content)
                    filtered.append(comment)
            
            # æŒ‰ç±»å‹å¹³è¡¡
            balanced = self.balance_comment_types(filtered)
            
            # éšæœºæ’åº
            random.shuffle(balanced)
            
            return balanced[:10]  # æœ€å¤šè¿”å›10æ¡
            
        except Exception as e:
            logging.error(f"è¿‡æ»¤è¯„è®ºå¤±è´¥: {e}")
            return comments
    
    def balance_comment_types(self, comments):
        """å¹³è¡¡ä¸åŒç±»å‹è¯„è®ºæ•°é‡"""
        type_groups = {}
        for comment in comments:
            comment_type = comment['type']
            if comment_type not in type_groups:
                type_groups[comment_type] = []
            type_groups[comment_type].append(comment)
        
        balanced = []
        max_per_type = 3
        
        for comment_type, type_comments in type_groups.items():
            balanced.extend(type_comments[:max_per_type])
        
        return balanced
    
    def customize_comment_style(self, comment, style='friendly'):
        """è‡ªå®šä¹‰è¯„è®ºé£æ ¼"""
        styles = {
            'friendly': {'suffix': '~', 'emoji': 'ğŸ˜Š'},
            'professional': {'suffix': 'ã€‚', 'emoji': ''},
            'casual': {'suffix': 'å“ˆå“ˆ', 'emoji': 'ğŸ˜„'},
            'polite': {'suffix': 'ï¼Œè°¢è°¢', 'emoji': 'ğŸ™'}
        }
        
        if style in styles:
            style_config = styles[style]
            # è¿™é‡Œå¯ä»¥æ ¹æ®é£æ ¼è°ƒæ•´è¯„è®º
            pass
        
        return comment
```

### 5. è¯„è®ºå‘å¸ƒå™¨
```python
# src/comment_publisher.py
from appium.webdriver.common.appiumby import AppiumBy
import time
import random
import logging

class CommentPublisher:
    def __init__(self, app_controller):
        self.app = app_controller
        self.driver = app_controller.driver
        self.anti_detection = {
            'min_interval': 15,  # æœ€å°é—´éš”15ç§’
            'max_interval': 45,  # æœ€å¤§é—´éš”45ç§’
            'typing_speed': (50, 150),  # æ‰“å­—é€Ÿåº¦åŒºé—´(æ¯«ç§’)
            'scroll_before_comment': True,  # è¯„è®ºå‰æ»šåŠ¨
            'random_pause': True  # éšæœºæš‚åœ
        }
    
    def publish_comments(self, comments, product_id):
        """å‘å¸ƒè¯„è®ºåˆ—è¡¨"""
        try:
            success_count = 0
            
            for i, comment in enumerate(comments):
                if self.publish_single_comment(comment, product_id):
                    success_count += 1
                    logging.info(f"è¯„è®ºå‘å¸ƒæˆåŠŸ: {comment['content']}")
                else:
                    logging.error(f"è¯„è®ºå‘å¸ƒå¤±è´¥: {comment['content']}")
                
                # å‘å¸ƒé—´éš”æ§åˆ¶
                if i < len(comments) - 1:  # ä¸æ˜¯æœ€åä¸€æ¡
                    interval = random.randint(
                        self.anti_detection['min_interval'],
                        self.anti_detection['max_interval']
                    )
                    time.sleep(interval)
            
            return success_count
            
        except Exception as e:
            logging.error(f"æ‰¹é‡å‘å¸ƒè¯„è®ºå¤±è´¥: {e}")
            return 0
    
    def publish_single_comment(self, comment, product_id):
        """å‘å¸ƒå•æ¡è¯„è®º"""
        try:
            # 1. æ»šåŠ¨åˆ°è¯„è®ºåŒº
            if not self.navigate_to_comment_area():
                return False
            
            # 2. ç‚¹å‡»è¯„è®ºè¾“å…¥æ¡†
            if not self.click_comment_input():
                return False
            
            # 3. æ¨¡æ‹Ÿäººç±»æ‰“å­—
            if not self.simulate_typing(comment['content']):
                return False
            
            # 4. æäº¤è¯„è®º
            if not self.submit_comment():
                return False
            
            # 5. éªŒè¯å‘å¸ƒæˆåŠŸ
            return self.verify_comment_posted()
            
        except Exception as e:
            logging.error(f"å‘å¸ƒè¯„è®ºå¤±è´¥: {e}")
            return False
    
    def navigate_to_comment_area(self):
        """å¯¼èˆªåˆ°è¯„è®ºåŒº"""
        try:
            # å¤šæ¬¡æ»šåŠ¨å¯»æ‰¾è¯„è®ºåŒº
            for _ in range(5):
                # æŸ¥æ‰¾è¯„è®ºç›¸å…³å…ƒç´ 
                comment_selectors = [
                    "//android.widget.EditText[contains(@hint,'è¯„è®º')]",
                    "//android.widget.EditText[contains(@hint,'ç•™è¨€')]",
                    "//*[contains(@resource-id,'comment_input')]",
                    "//android.widget.TextView[contains(@text,'å†™è¯„è®º')]",
                    "//android.widget.TextView[contains(@text,'è¯´ç‚¹ä»€ä¹ˆ')]"
                ]
                
                for selector in comment_selectors:
                    try:
                        element = self.driver.find_element(AppiumBy.XPATH, selector)
                        if element.is_displayed():
                            return True
                    except:
                        continue
                
                # å¦‚æœæ²¡æ‰¾åˆ°ï¼Œç»§ç»­æ»šåŠ¨
                self.app.scroll_page('down')
                time.sleep(2)
            
            # å°è¯•ç‚¹å‡»è¯„è®ºæŒ‰é’®æˆ–å›¾æ ‡
            comment_buttons = [
                "//android.widget.TextView[contains(@text,'è¯„è®º')]",
                "//android.widget.ImageView[contains(@resource-id,'comment')]"
            ]
            
            for button_selector in comment_buttons:
                try:
                    button = self.driver.find_element(AppiumBy.XPATH, button_selector)
                    button.click()
                    time.sleep(2)
                    return True
                except:
                    continue
            
            return False
            
        except Exception as e:
            logging.error(f"å¯¼èˆªåˆ°è¯„è®ºåŒºå¤±è´¥: {e}")
            return False
    
    def click_comment_input(self):
        """ç‚¹å‡»è¯„è®ºè¾“å…¥æ¡†"""
        try:
            # å¤šç§è¾“å…¥æ¡†é€‰æ‹©å™¨
            input_selectors = [
                "//android.widget.EditText[contains(@hint,'è¯„è®º')]",
                "//android.widget.EditText[contains(@hint,'ç•™è¨€')]",
                "//android.widget.EditText[contains(@hint,'è¯´ç‚¹ä»€ä¹ˆ')]",
                "//*[contains(@resource-id,'comment_input')]",
                "//*[contains(@resource-id,'edit_text')]"
            ]
            
            for selector in input_selectors:
                try:
                    input_element = self.driver.find_element(AppiumBy.XPATH, selector)
                    if input_element.is_displayed() and input_element.is_enabled():
                        # å…ˆç‚¹å‡»æ¿€æ´»
                        input_element.click()
                        time.sleep(1)
                        
                        # æ¸…ç©ºç°æœ‰å†…å®¹
                        input_element.clear()
                        time.sleep(0.5)
                        
                        return True
                        
                except Exception as e:
                    continue
            
            return False
            
        except Exception as e:
            logging.error(f"ç‚¹å‡»è¯„è®ºè¾“å…¥æ¡†å¤±è´¥: {e}")
            return False
    
    def simulate_typing(self, text):
        """æ¨¡æ‹Ÿäººç±»æ‰“å­—"""
        try:
            # è·å–å½“å‰æ´»åŠ¨çš„è¾“å…¥æ¡†
            active_input = self.get_active_input_element()
            if not active_input:
                return False
            
            # æ¨¡æ‹Ÿé€å­—ç¬¦è¾“å…¥
            for char in text:
                active_input.send_keys(char)
                
                # éšæœºæ‰“å­—é—´éš”
                interval = random.randint(
                    self.anti_detection['typing_speed'][0],
                    self.anti_detection['typing_speed'][1]
                ) / 1000.0
                time.sleep(interval)
            
            # éšæœºæš‚åœæ€è€ƒ
            if self.anti_detection['random_pause']:
                pause_time = random.uniform(0.5, 2.0)
                time.sleep(pause_time)
            
            return True
            
        except Exception as e:
            logging.error(f"æ¨¡æ‹Ÿæ‰“å­—å¤±è´¥: {e}")
            return False
    
    def get_active_input_element(self):
        """è·å–å½“å‰æ´»åŠ¨çš„è¾“å…¥å…ƒç´ """
        try:
            # æŸ¥æ‰¾å·²è·å¾—ç„¦ç‚¹çš„è¾“å…¥æ¡†
            focused_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.EditText[@focused='true']"
            )
            
            if focused_elements:
                return focused_elements[0]
            
            # å¦‚æœæ²¡æœ‰ç„¦ç‚¹å…ƒç´ ï¼Œè¿”å›å¯è§çš„è¾“å…¥æ¡†
            visible_inputs = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.EditText"
            )
            
            for input_elem in visible_inputs:
                if input_elem.is_displayed() and input_elem.is_enabled():
                    return input_elem
            
            return None
            
        except Exception as e:
            logging.error(f"è·å–æ´»åŠ¨è¾“å…¥å…ƒç´ å¤±è´¥: {e}")
            return None
    
    def submit_comment(self):
        """æäº¤è¯„è®º"""
        try:
            # æŸ¥æ‰¾å‘é€æŒ‰é’®
            submit_selectors = [
                "//android.widget.Button[contains(@text,'å‘é€')]",
                "//android.widget.Button[contains(@text,'æäº¤')]",
                "//android.widget.TextView[contains(@text,'å‘é€')]",
                "//*[contains(@resource-id,'send') or contains(@resource-id,'submit')]",
                "//android.widget.ImageView[contains(@resource-id,'send')]"
            ]
            
            for selector in submit_selectors:
                try:
                    submit_btn = self.driver.find_element(AppiumBy.XPATH, selector)
                    if submit_btn.is_displayed() and submit_btn.is_enabled():
                        # éšæœºå»¶è¿Ÿåç‚¹å‡»
                        delay = random.uniform(0.3, 1.0)
                        time.sleep(delay)
                        
                        submit_btn.click()
                        time.sleep(2)
                        
                        return True
                        
                except:
                    continue
            
            # å°è¯•å›è½¦é”®æäº¤
            try:
                self.driver.press_keycode(66)  # Enteré”®
                time.sleep(2)
                return True
            except:
                pass
            
            return False
            
        except Exception as e:
            logging.error(f"æäº¤è¯„è®ºå¤±è´¥: {e}")
            return False
    
    def verify_comment_posted(self):
        """éªŒè¯è¯„è®ºå·²å‘å¸ƒ"""
        try:
            # ç­‰å¾…ä¸€æ®µæ—¶é—´è®©è¯„è®ºæ˜¾ç¤º
            time.sleep(3)
            
            # æŸ¥æ‰¾æˆåŠŸæç¤ºæˆ–è¯„è®ºæ˜¾ç¤º
            success_indicators = [
                "//android.widget.TextView[contains(@text,'è¯„è®ºæˆåŠŸ')]",
                "//android.widget.TextView[contains(@text,'å‘é€æˆåŠŸ')]",
                "//android.widget.Toast[contains(@text,'æˆåŠŸ')]"
            ]
            
            for indicator in success_indicators:
                try:
                    self.driver.find_element(AppiumBy.XPATH, indicator)
                    return True
                except:
                    continue
            
            # æ£€æŸ¥è¾“å…¥æ¡†æ˜¯å¦å·²æ¸…ç©ºï¼ˆæš—ç¤ºå‘é€æˆåŠŸï¼‰
            input_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.EditText"
            )
            
            for input_elem in input_elements:
                if input_elem.text == "":
                    return True
            
            # é»˜è®¤è®¤ä¸ºæˆåŠŸï¼ˆæŸäº›ç‰ˆæœ¬å¯èƒ½æ²¡æœ‰æ˜æ˜¾æç¤ºï¼‰
            return True
            
        except Exception as e:
            logging.error(f"éªŒè¯è¯„è®ºå‘å¸ƒçŠ¶æ€å¤±è´¥: {e}")
            return True  # é»˜è®¤æˆåŠŸ
    
    def handle_comment_restrictions(self):
        """å¤„ç†è¯„è®ºé™åˆ¶"""
        try:
            # æ£€æŸ¥æ˜¯å¦æœ‰é™åˆ¶æç¤º
            restriction_texts = [
                "è¯„è®ºå¤ªé¢‘ç¹",
                "è¯·ç¨åå†è¯•",
                "è¯„è®ºå¤±è´¥",
                "ç½‘ç»œå¼‚å¸¸",
                "ç³»ç»Ÿç»´æŠ¤"
            ]
            
            all_elements = self.driver.find_elements(
                AppiumBy.XPATH,
                "//android.widget.TextView"
            )
            
            for element in all_elements:
                text = element.text
                for restriction in restriction_texts:
                    if restriction in text:
                        logging.warning(f"é‡åˆ°è¯„è®ºé™åˆ¶: {text}")
                        return False
            
            return True
            
        except Exception as e:
            logging.error(f"å¤„ç†è¯„è®ºé™åˆ¶å¤±è´¥: {e}")
            return True
    
    def get_comment_statistics(self):
        """è·å–è¯„è®ºç»Ÿè®¡"""
        try:
            stats = {
                'total_attempted': 0,
                'successful': 0,
                'failed': 0,
                'restricted': 0
            }
            
            # ä»æ•°æ®åº“è·å–ç»Ÿè®¡ä¿¡æ¯
            from database import Database
            db = Database()
            stats = db.get_comment_statistics()
            
            return stats
            
        except Exception as e:
            logging.error(f"è·å–è¯„è®ºç»Ÿè®¡å¤±è´¥: {e}")
            return {}
```

### 6. GUIç®¡ç†ç•Œé¢
```python
# src/gui.py
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import json
from datetime import datetime

class CommentAssistantGUI:
    def __init__(self, assistant):
        self.assistant = assistant
        self.root = tk.Tk()
        self.setup_ui()
        self.task_running = False
    
    def setup_ui(self):
        """è®¾ç½®ç•Œé¢"""
        self.root.title("è¯„è®ºåŠ©æ‰‹")
        self.root.geometry("900x700")
        self.root.resizable(True, True)
        
        # åˆ›å»ºä¸»å¸ƒå±€
        self.create_main_layout()
        
        # åˆ›å»ºèœå•æ 
        self.create_menu()
        
        # è®¾ç½®çª—å£å…³é—­äº‹ä»¶
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_main_layout(self):
        """åˆ›å»ºä¸»å¸ƒå±€"""
        # ä¸»å®¹å™¨
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # åˆ›å»ºç¬”è®°æœ¬æ§ä»¶ï¼ˆé€‰é¡¹å¡ï¼‰
        notebook = ttk.Notebook(main_container)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # ä»»åŠ¡é…ç½®é€‰é¡¹å¡
        self.create_task_config_tab(notebook)
        
        # è¿è¡Œç›‘æ§é€‰é¡¹å¡
        self.create_monitoring_tab(notebook)
        
        # æ•°æ®ç»Ÿè®¡é€‰é¡¹å¡
        self.create_statistics_tab(notebook)
        
        # è®¾ç½®é€‰é¡¹å¡
        self.create_settings_tab(notebook)
    
    def create_task_config_tab(self, parent):
        """åˆ›å»ºä»»åŠ¡é…ç½®é€‰é¡¹å¡"""
        tab_frame = ttk.Frame(parent)
        parent.add(tab_frame, text="ä»»åŠ¡é…ç½®")
        
        # å•†å“URLè¾“å…¥åŒºåŸŸ
        url_frame = ttk.LabelFrame(tab_frame, text="å•†å“URLåˆ—è¡¨")
        url_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # URLè¾“å…¥æ–‡æœ¬æ¡†
        self.url_text = scrolledtext.ScrolledText(
            url_frame, height=8, wrap=tk.WORD
        )
        self.url_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # æ‰¹é‡å¯¼å…¥æŒ‰é’®
        url_buttons_frame = ttk.Frame(url_frame)
        url_buttons_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(
            url_buttons_frame, text="ä»æ–‡ä»¶å¯¼å…¥", 
            command=self.import_urls_from_file
        ).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(
            url_buttons_frame, text="æ¸…ç©ºåˆ—è¡¨", 
            command=self.clear_url_list
        ).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(
            url_buttons_frame, text="ç¤ºä¾‹URL", 
            command=self.load_sample_urls
        ).pack(side=tk.LEFT, padx=5)
        
        # è¯„è®ºç±»å‹é€‰æ‹©
        comment_frame = ttk.LabelFrame(tab_frame, text="è¯„è®ºç±»å‹è®¾ç½®")
        comment_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # è¯„è®ºç±»å‹å¤é€‰æ¡†
        self.comment_types = {
            'inquiry': tk.BooleanVar(value=True),
            'interest': tk.BooleanVar(value=True), 
            'comparison': tk.BooleanVar(value=False),
            'compliment': tk.BooleanVar(value=True),
            'concern': tk.BooleanVar(value=False)
        }
        
        comment_checkboxes = ttk.Frame(comment_frame)
        comment_checkboxes.pack(fill=tk.X, padx=5, pady=5)
        
        type_labels = {
            'inquiry': 'è¯¢ä»·å‹',
            'interest': 'æ„Ÿå…´è¶£å‹',
            'comparison': 'å¯¹æ¯”å’¨è¯¢å‹',
            'compliment': 'å¤¸èµå‹',
            'concern': 'å…³æ³¨å‹'
        }
        
        for i, (type_key, var) in enumerate(self.comment_types.items()):
            ttk.Checkbutton(
                comment_checkboxes,
                text=type_labels[type_key],
                variable=var
            ).grid(row=i//3, column=i%3, sticky=tk.W, padx=10, pady=2)
        
        # ä»»åŠ¡æ§åˆ¶åŒºåŸŸ
        control_frame = ttk.LabelFrame(tab_frame, text="ä»»åŠ¡æ§åˆ¶")
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        control_buttons = ttk.Frame(control_frame)
        control_buttons.pack(fill=tk.X, padx=5, pady=5)
        
        self.start_button = ttk.Button(
            control_buttons, text="å¼€å§‹ä»»åŠ¡", 
            command=self.start_task, style="Accent.TButton"
        )
        self.start_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = ttk.Button(
            control_buttons, text="åœæ­¢ä»»åŠ¡", 
            command=self.stop_task, state="disabled"
        )
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        self.pause_button = ttk.Button(
            control_buttons, text="æš‚åœä»»åŠ¡", 
            command=self.pause_task, state="disabled"
        )
        self.pause_button.pack(side=tk.LEFT, padx=5)
        
        # è¿›åº¦æ˜¾ç¤º
        progress_frame = ttk.Frame(control_frame)
        progress_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(progress_frame, text="ä»»åŠ¡è¿›åº¦:").pack(side=tk.LEFT)
        
        self.progress_var = tk.StringVar(value="0/0")
        self.progress_label = ttk.Label(progress_frame, textvariable=self.progress_var)
        self.progress_label.pack(side=tk.LEFT, padx=10)
        
        self.progress_bar = ttk.Progressbar(
            progress_frame, length=300, mode='determinate'
        )
        self.progress_bar.pack(side=tk.RIGHT, padx=5)
    
    def create_monitoring_tab(self, parent):
        """åˆ›å»ºè¿è¡Œç›‘æ§é€‰é¡¹å¡"""
        tab_frame = ttk.Frame(parent)
        parent.add(tab_frame, text="è¿è¡Œç›‘æ§")
        
        # çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ
        status_frame = ttk.LabelFrame(tab_frame, text="ç³»ç»ŸçŠ¶æ€")
        status_frame.pack(fill=tk.X, padx=5, pady=5)
        
        status_grid = ttk.Frame(status_frame)
        status_grid.pack(fill=tk.X, padx=5, pady=5)
        
        # çŠ¶æ€æŒ‡æ ‡
        self.status_vars = {
            'app_status': tk.StringVar(value="æœªè¿æ¥"),
            'current_product': tk.StringVar(value="æ— "),
            'comments_generated': tk.StringVar(value="0"),
            'comments_published': tk.StringVar(value="0")
        }
        
        status_labels = {
            'app_status': "APPçŠ¶æ€:",
            'current_product': "å½“å‰å•†å“:",
            'comments_generated': "ç”Ÿæˆè¯„è®º:",
            'comments_published': "å‘å¸ƒè¯„è®º:"
        }
        
        for i, (key, label) in enumerate(status_labels.items()):
            ttk.Label(status_grid, text=label).grid(
                row=i//2, column=(i%2)*2, sticky=tk.W, padx=5, pady=2
            )
            ttk.Label(status_grid, textvariable=self.status_vars[key]).grid(
                row=i//2, column=(i%2)*2+1, sticky=tk.W, padx=5, pady=2
            )
        
        # æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸ
        log_frame = ttk.LabelFrame(tab_frame, text="è¿è¡Œæ—¥å¿—")
        log_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # æ—¥å¿—æ–‡æœ¬æ¡†
        self.log_text = scrolledtext.ScrolledText(
            log_frame, height=15, state=tk.DISABLED
        )
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # æ—¥å¿—æ§åˆ¶æŒ‰é’®
        log_buttons = ttk.Frame(log_frame)
        log_buttons.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(
            log_buttons, text="æ¸…ç©ºæ—¥å¿—", 
            command=self.clear_log
        ).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(
            log_buttons, text="ä¿å­˜æ—¥å¿—", 
            command=self.save_log
        ).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(
            log_buttons, text="åˆ·æ–°", 
            command=self.refresh_log
        ).pack(side=tk.RIGHT, padx=5)
    
    def create_statistics_tab(self, parent):
        """åˆ›å»ºæ•°æ®ç»Ÿè®¡é€‰é¡¹å¡"""
        tab_frame = ttk.Frame(parent)
        parent.add(tab_frame, text="æ•°æ®ç»Ÿè®¡")
        
        # ä»Šæ—¥ç»Ÿè®¡
        today_frame = ttk.LabelFrame(tab_frame, text="ä»Šæ—¥ç»Ÿè®¡")
        today_frame.pack(fill=tk.X, padx=5, pady=5)
        
        today_grid = ttk.Frame(today_frame)
        today_grid.pack(fill=tk.X, padx=5, pady=5)
        
        self.today_stats = {
            'products_processed': tk.StringVar(value="0"),
            'comments_generated': tk.StringVar(value="0"),
            'comments_published': tk.StringVar(value="0"),
            'success_rate': tk.StringVar(value="0%")
        }
        
        today_labels = {
            'products_processed': "å¤„ç†å•†å“:",
            'comments_generated': "ç”Ÿæˆè¯„è®º:",
            'comments_published': "å‘å¸ƒè¯„è®º:",
            'success_rate': "æˆåŠŸç‡:"
        }
        
        for i, (key, label) in enumerate(today_labels.items()):
            ttk.Label(today_grid, text=label).grid(
                row=i//2, column=(i%2)*2, sticky=tk.W, padx=10, pady=5
            )
            ttk.Label(today_grid, textvariable=self.today_stats[key]).grid(
                row=i//2, column=(i%2)*2+1, sticky=tk.W, padx=10, pady=5
            )
        
        # å†å²è®°å½•è¡¨æ ¼
        history_frame = ttk.LabelFrame(tab_frame, text="å†å²è®°å½•")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # åˆ›å»ºè¡¨æ ¼
        columns = ("æ—¶é—´", "å•†å“æ ‡é¢˜", "ç”Ÿæˆè¯„è®ºæ•°", "å‘å¸ƒæˆåŠŸæ•°", "æˆåŠŸç‡")
        self.history_tree = ttk.Treeview(
            history_frame, columns=columns, show="headings", height=12
        )
        
        for col in columns:
            self.history_tree.heading(col, text=col)
            self.history_tree.column(col, width=120)
        
        # æ»šåŠ¨æ¡
        history_scrollbar = ttk.Scrollbar(
            history_frame, orient=tk.VERTICAL, command=self.history_tree.yview
        )
        self.history_tree.configure(yscrollcommand=history_scrollbar.set)
        
        self.history_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # ç»Ÿè®¡æŒ‰é’®
        stats_buttons = ttk.Frame(history_frame)
        stats_buttons.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(
            stats_buttons, text="åˆ·æ–°æ•°æ®", 
            command=self.refresh_statistics
        ).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(
            stats_buttons, text="å¯¼å‡ºæŠ¥å‘Š", 
            command=self.export_report
        ).pack(side=tk.LEFT, padx=5)
    
    def create_settings_tab(self, parent):
        """åˆ›å»ºè®¾ç½®é€‰é¡¹å¡"""
        tab_frame = ttk.Frame(parent)
        parent.add(tab_frame, text="ç³»ç»Ÿè®¾ç½®")
        
        # DeepSeek APIè®¾ç½®
        api_frame = ttk.LabelFrame(tab_frame, text="DeepSeek API é…ç½®")
        api_frame.pack(fill=tk.X, padx=5, pady=5)
        
        api_grid = ttk.Frame(api_frame)
        api_grid.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(api_grid, text="API Key:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.api_key_entry = ttk.Entry(api_grid, width=50, show="*")
        self.api_key_entry.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        ttk.Button(api_grid, text="æµ‹è¯•è¿æ¥", command=self.test_api_connection).grid(
            row=0, column=2, padx=5, pady=5
        )
        
        # åæ£€æµ‹è®¾ç½®
        detection_frame = ttk.LabelFrame(tab_frame, text="åæ£€æµ‹è®¾ç½®")
        detection_frame.pack(fill=tk.X, padx=5, pady=5)
        
        detection_grid = ttk.Frame(detection_frame)
        detection_grid.pack(fill=tk.X, padx=5, pady=5)
        
        # è¯„è®ºé—´éš”è®¾ç½®
        ttk.Label(detection_grid, text="è¯„è®ºé—´éš”(ç§’):").grid(
            row=0, column=0, sticky=tk.W, padx=5, pady=5
        )
        
        interval_frame = ttk.Frame(detection_grid)
        interval_frame.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        self.min_interval = tk.IntVar(value=15)
        self.max_interval = tk.IntVar(value=45)
        
        ttk.Entry(interval_frame, textvariable=self.min_interval, width=8).pack(side=tk.LEFT)
        ttk.Label(interval_frame, text=" - ").pack(side=tk.LEFT)
        ttk.Entry(interval_frame, textvariable=self.max_interval, width=8).pack(side=tk.LEFT)
        
        # æ¯å°æ—¶æœ€å¤§è¯„è®ºæ•°
        ttk.Label(detection_grid, text="æ¯å°æ—¶æœ€å¤§è¯„è®ºæ•°:").grid(
            row=1, column=0, sticky=tk.W, padx=5, pady=5
        )
        
        self.max_hourly_comments = tk.IntVar(value=20)
        ttk.Entry(detection_grid, textvariable=self.max_hourly_comments, width=10).grid(
            row=1, column=1, sticky=tk.W, padx=5, pady=5
        )
        
        # è®¾å¤‡è®¾ç½®
        device_frame = ttk.LabelFrame(tab_frame, text="è®¾å¤‡è®¾ç½®")
        device_frame.pack(fill=tk.X, padx=5, pady=5)
        
        device_grid = ttk.Frame(device_frame)
        device_grid.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(device_grid, text="è®¾å¤‡ID:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.device_id_entry = ttk.Entry(device_grid, width=30)
        self.device_id_entry.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        ttk.Button(device_grid, text="æ£€æµ‹è®¾å¤‡", command=self.detect_devices).grid(
            row=0, column=2, padx=5, pady=5
        )
        
        # ä¿å­˜è®¾ç½®æŒ‰é’®
        ttk.Button(
            tab_frame, text="ä¿å­˜è®¾ç½®", 
            command=self.save_settings
        ).pack(pady=10)
    
    def create_menu(self):
        """åˆ›å»ºèœå•æ """
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # æ–‡ä»¶èœå•
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="æ–‡ä»¶", menu=file_menu)
        file_menu.add_command(label="å¯¼å…¥URLåˆ—è¡¨", command=self.import_urls_from_file)
        file_menu.add_command(label="å¯¼å‡ºé…ç½®", command=self.export_config)
        file_menu.add_command(label="å¯¼å…¥é…ç½®", command=self.import_config)
        file_menu.add_separator()
        file_menu.add_command(label="é€€å‡º", command=self.on_closing)
        
        # å·¥å…·èœå•
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="å·¥å…·", menu=tools_menu)
        tools_menu.add_command(label="æ¸…ç©ºæ•°æ®åº“", command=self.clear_database)
        tools_menu.add_command(label="å¤‡ä»½æ•°æ®", command=self.backup_data)
        tools_menu.add_command(label="ç³»ç»Ÿè¯Šæ–­", command=self.system_diagnosis)
        
        # å¸®åŠ©èœå•
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="å¸®åŠ©", menu=help_menu)
        help_menu.add_command(label="ä½¿ç”¨è¯´æ˜", command=self.show_help)
        help_menu.add_command(label="å…³äº", command=self.show_about)
    
    # äº‹ä»¶å¤„ç†æ–¹æ³•
    def start_task(self):
        """å¼€å§‹ä»»åŠ¡"""
        try:
            # è·å–URLåˆ—è¡¨
            urls = self.get_url_list()
            if not urls:
                messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆæ·»åŠ å•†å“URL")
                return
            
            # è·å–é€‰ä¸­çš„è¯„è®ºç±»å‹
            selected_types = [
                type_key for type_key, var in self.comment_types.items() 
                if var.get()
            ]
            
            if not selected_types:
                messagebox.showwarning("è­¦å‘Š", "è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¯„è®ºç±»å‹")
                return
            
            # æ›´æ–°UIçŠ¶æ€
            self.task_running = True
            self.start_button.config(state="disabled")
            self.stop_button.config(state="normal")
            self.pause_button.config(state="normal")
            
            # åœ¨æ–°çº¿ç¨‹ä¸­å¯åŠ¨ä»»åŠ¡
            task_thread = threading.Thread(
                target=self.run_task_thread,
                args=(urls, selected_types),
                daemon=True
            )
            task_thread.start()
            
            self.add_log("ä»»åŠ¡å·²å¯åŠ¨")
            
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"å¯åŠ¨ä»»åŠ¡å¤±è´¥: {e}")
    
    def stop_task(self):
        """åœæ­¢ä»»åŠ¡"""
        self.task_running = False
        self.assistant.running = False
        
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.pause_button.config(state="disabled")
        
        self.add_log("ä»»åŠ¡å·²åœæ­¢")
    
    def pause_task(self):
        """æš‚åœä»»åŠ¡"""
        # å®ç°æš‚åœé€»è¾‘
        pass
    
    def run_task_thread(self, urls, comment_types):
        """åœ¨çº¿ç¨‹ä¸­è¿è¡Œä»»åŠ¡"""
        try:
            self.assistant.start_batch_task(urls, comment_types)
        except Exception as e:
            self.root.after(0, lambda: self.show_error(f"ä»»åŠ¡æ‰§è¡Œé”™è¯¯: {e}"))
        finally:
            self.root.after(0, self.task_finished)
    
    def task_finished(self):
        """ä»»åŠ¡å®Œæˆ"""
        self.task_running = False
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.pause_button.config(state="disabled")
        self.add_log("ä»»åŠ¡å·²å®Œæˆ")
    
    def get_url_list(self):
        """è·å–URLåˆ—è¡¨"""
        text = self.url_text.get("1.0", tk.END).strip()
        urls = [url.strip() for url in text.split('\n') if url.strip()]
        return urls
    
    def update_progress(self, current, total):
        """æ›´æ–°è¿›åº¦"""
        self.progress_var.set(f"{current}/{total}")
        if total > 0:
            self.progress_bar['value'] = (current / total) * 100
    
    def add_log(self, message):
        """æ·»åŠ æ—¥å¿—"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, log_entry)
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
    
    def show_error(self, message):
        """æ˜¾ç¤ºé”™è¯¯"""
        messagebox.showerror("é”™è¯¯", message)
        self.add_log(f"é”™è¯¯: {message}")
    
    def show_task_report(self, report):
        """æ˜¾ç¤ºä»»åŠ¡æŠ¥å‘Š"""
        report_text = f"""
ä»»åŠ¡å®ŒæˆæŠ¥å‘Š
â•â•â•â•â•â•â•â•â•â•â•â•
å¤„ç†å•†å“æ€»æ•°: {report['total']}
æˆåŠŸå¤„ç†æ•°é‡: {report['completed']}
å¤±è´¥æ•°é‡: {report['errors']}
æˆåŠŸç‡: {report['success_rate']:.1%}
"""
        messagebox.showinfo("ä»»åŠ¡æŠ¥å‘Š", report_text)
    
    # å…¶ä»–UIè¾…åŠ©æ–¹æ³•
    def import_urls_from_file(self):
        """ä»æ–‡ä»¶å¯¼å…¥URL"""
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©URLæ–‡ä»¶",
            filetypes=[("æ–‡æœ¬æ–‡ä»¶", "*.txt"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        
        if filename:
            try:
                with open(filename, 'r', encoding='utf-8') as file:
                    urls = file.read()
                    self.url_text.delete("1.0", tk.END)
                    self.url_text.insert("1.0", urls)
                self.add_log(f"å·²å¯¼å…¥URLæ–‡ä»¶: {filename}")
            except Exception as e:
                messagebox.showerror("é”™è¯¯", f"å¯¼å…¥æ–‡ä»¶å¤±è´¥: {e}")
    
    def clear_url_list(self):
        """æ¸…ç©ºURLåˆ—è¡¨"""
        self.url_text.delete("1.0", tk.END)
    
    def load_sample_urls(self):
        """åŠ è½½ç¤ºä¾‹URL"""
        sample_urls = """https://www.xianyu.com/item/123456789
https://www.xianyu.com/item/987654321
https://www.xianyu.com/item/456789123"""
        
        self.url_text.delete("1.0", tk.END)
        self.url_text.insert("1.0", sample_urls)
    
    def on_closing(self):
        """çª—å£å…³é—­äº‹ä»¶"""
        if self.task_running:
            if messagebox.askokcancel("é€€å‡º", "ä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œç¡®å®šè¦é€€å‡ºå—ï¼Ÿ"):
                self.stop_task()
                self.root.after(1000, self.root.destroy)
        else:
            self.root.destroy()
    
    def run(self):
        """è¿è¡ŒGUI"""
        self.root.mainloop()
```

## ğŸš€ éƒ¨ç½²å’Œè¿è¡Œ

### æœ¬åœ°éƒ¨ç½²æ­¥éª¤

#### 1. ç¯å¢ƒå‡†å¤‡
```bash
# ç¡®ä¿Androidè®¾å¤‡å·²è¿æ¥å¹¶å¼€å¯è°ƒè¯•
adb devices

# å¯åŠ¨Appium Server
appium

# åœ¨æ–°ç»ˆç«¯å¯åŠ¨Pythonç¨‹åº
cd xianyu-comment-assistant
python src/main.py
```

#### 2. è®¾å¤‡é…ç½®
```bash
# çœŸæœºé…ç½®æ­¥éª¤
1. å¼€å¯å¼€å‘è€…é€‰é¡¹
2. å¯ç”¨USBè°ƒè¯•
3. å®‰è£…APPå¹¶æ‰‹åŠ¨ç™»å½•
4. ä¿æŒAPPåœ¨å‰å°æˆ–åå°è¿è¡Œ

# æ¨¡æ‹Ÿå™¨é…ç½®ï¼ˆæ¨èå¤œç¥æ¨¡æ‹Ÿå™¨ï¼‰
1. ä¸‹è½½å®‰è£…å¤œç¥æ¨¡æ‹Ÿå™¨
2. å¯åŠ¨æ¨¡æ‹Ÿå™¨
3. å®‰è£…APP
4. æ‰‹åŠ¨ç™»å½•è´¦å·
```

#### 3. ä½¿ç”¨æµç¨‹
```
1. æ‰‹åŠ¨ç™»å½•APP
2. å¯åŠ¨åŠ©æ‰‹ç¨‹åº
3. é…ç½®DeepSeek APIå¯†é’¥
4. æ·»åŠ å•†å“URLåˆ—è¡¨
5. é€‰æ‹©è¯„è®ºç±»å‹
6. å¼€å§‹æ‰§è¡Œä»»åŠ¡
7. ç›‘æ§è¿è¡ŒçŠ¶æ€
```

## ğŸ”’ å®‰å…¨å’Œé£é™©æ§åˆ¶

### åæ£€æµ‹æœºåˆ¶
```python
# åæ£€æµ‹é…ç½®ç¤ºä¾‹
ANTI_DETECTION_CONFIG = {
    # æ—¶é—´æ§åˆ¶
    'comment_interval': (15, 45),      # è¯„è®ºé—´éš”15-45ç§’
    'daily_limit': 100,                # æ¯æ—¥æœ€å¤§è¯„è®ºæ•°
    'hourly_limit': 20,                # æ¯å°æ—¶æœ€å¤§è¯„è®ºæ•°
    
    # è¡Œä¸ºæ¨¡æ‹Ÿ
    'typing_speed': (50, 150),         # æ‰“å­—é€Ÿåº¦åŒºé—´
    'scroll_before_comment': True,     # è¯„è®ºå‰æ»šåŠ¨
    'random_pause': True,              # éšæœºæš‚åœ
    
    # å†…å®¹å¤šæ ·åŒ–
    'content_variation': True,         # å†…å®¹å˜åŒ–
    'template_rotation': True,         # æ¨¡æ¿è½®æ¢
}
```

### å®‰å…¨æªæ–½
- **æœ¬åœ°è¿è¡Œ**ï¼šæ‰€æœ‰æ•°æ®æœ¬åœ°å­˜å‚¨
- **æ‰‹åŠ¨ç™»å½•**ï¼šç”¨æˆ·å®Œå…¨æ§åˆ¶è´¦å·
- **è¡Œä¸ºæ¨¡æ‹Ÿ**ï¼šæ¨¡æ‹ŸçœŸå®ç”¨æˆ·æ“ä½œ
- **é¢‘ç‡æ§åˆ¶**ï¼šé¿å…è¿‡äºé¢‘ç¹æ“ä½œ
- **å¼‚å¸¸ç›‘æ§**ï¼šè‡ªåŠ¨æ£€æµ‹å’Œå¤„ç†å¼‚å¸¸

## ğŸ“Š æ•ˆæœè¯„ä¼°

### å…³é”®æŒ‡æ ‡
- **å¤„ç†æ•ˆç‡**ï¼šæ¯å°æ—¶å¤„ç†å•†å“æ•°é‡
- **ç”Ÿæˆè´¨é‡**ï¼šAIæ–‡æ¡ˆçš„ç›¸å…³æ€§å’Œè‡ªç„¶åº¦
- **å‘å¸ƒæˆåŠŸç‡**ï¼šè¯„è®ºæˆåŠŸå‘å¸ƒçš„æ¯”ä¾‹
- **æ£€æµ‹è§„é¿ç‡**ï¼šæˆåŠŸé¿å…å¹³å°æ£€æµ‹çš„æ¯”ä¾‹

### ä¼˜åŒ–å»ºè®®
1. **å®šæœŸæ›´æ–°**ï¼šä¿æŒä¸é—²é±¼APPç‰ˆæœ¬åŒæ­¥
2. **æ¨¡æ¿ä¼˜åŒ–**ï¼šæ ¹æ®æ•ˆæœè°ƒæ•´æ–‡æ¡ˆæ¨¡æ¿
3. **è¡Œä¸ºè°ƒæ•´**ï¼šè§‚å¯Ÿå¹³å°å˜åŒ–è°ƒæ•´æ“ä½œç­–ç•¥
4. **æ•°æ®åˆ†æ**ï¼šåˆ†æå‘å¸ƒæ•ˆæœä¼˜åŒ–æŠ•æ”¾ç­–ç•¥

---

**ç³»ç»Ÿç‰ˆæœ¬**: v1.0.0  
**æ–‡æ¡£æ›´æ–°**: 2025-01-25  
**é€‚ç”¨å¹³å°**: Android  
**æŠ€æœ¯æ”¯æŒ**: åŸºäºæ‰‹åŠ¨ç™»å½•çš„æœ¬åœ°è¿è¡Œæ¶æ„